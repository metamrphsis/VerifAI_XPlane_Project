Now I am going to share some more Scenic documentation with you for you to learn Scenic programming language in detail so that you can help me write scenic program to complete my project. Please read, study, and analyze the following Syntax Guide and Language Reference Subsection from the Language and Tool Reference section from the Scenic documentation in detail:

..  _syntax_guide:

Syntax Guide
============

This page summarizes the syntax of Scenic, excluding the basic syntax of variable assignments, functions, loops, etc., which is identical to Python (see the `Python Tutorial <https://docs.python.org/3/tutorial/>`_ for an introduction).
For more details, click the links for individual language constructs to go to the corresponding section of the `language reference`.


Primitive Data Types
--------------------
============================= ==================================================================
`Booleans <Boolean>`          expressing truth values
`Scalars <Scalar>`            representing distances, angles, etc. as floating-point numbers
`Vectors <Vector>`            representing positions and offsets in space
`Headings <Heading>`   		    representing 2D orientations in the XY plane
`Orientations <Orientation>`  representing 3D orientations in space
`Vector Fields <VectorField>` associating an orientation to each point in space
`Regions <Region>`            representing sets of points in space
`Shapes <Shape>`              representing shapes (regions modulo similarity)
============================= ==================================================================


Distributions
-------------
================================================================ ==================================
:sampref:`Range({low}, {high})`                                  uniformly-distributed real number in the interval
:sampref:`DiscreteRange({low}, {high})`                          uniformly-distributed integer in the (fixed) interval
:sampref:`Normal({mean}, {stdDev})`                              normal distribution with the given mean and standard deviation
:sampref:`TruncatedNormal({mean}, {stdDev}, {low}, {high})`      normal distribution truncated to the given window
:sampref:`Uniform({value}, {...})`                               uniform over a finite set of values
:sampref:`Discrete(\{{value}: {weight}, {...}\})<DiscreteDistr>` discrete with given values and weights
:sampref:`new Point in {region} <uniform_in_region>`                 uniformly-distributed `Point` in a region
================================================================ ==================================

Statements
----------

Compound Statements
+++++++++++++++++++

.. list-table::
   :header-rows: 1

   * - Syntax
     - Meaning
   * - :sampref:`class {name}[({superclass})]: <classDef>`
     - Defines a Scenic class.
   * - :sampref:`behavior {name}({arguments}): <behaviorDef>`
     - Defines a :term:`dynamic behavior`.
   * - :sampref:`monitor {name}({arguments}): <monitorDef>`
     - Defines a :term:`monitor`.
   * - :sampref:`scenario {name}({arguments}): <modularScenarioDef>`
     - Defines a :term:`modular scenario`.
   * - :sampref:`try: {...} interrupt when {boolean}:<tryInterruptStmt>`
     - Run code with interrupts inside a dynamic behavior or modular scenario.

Simple Statements
+++++++++++++++++

.. list-table::
   :header-rows: 1

   * - Syntax
     - Meaning
   * - :sampref:`model {name}`
     - Select the :term:`world model`.
   * - :sampref:`import {module}`
     - Import a Scenic or Python module.
   * - :sampref:`param {name} = {value}, {...}`
     - Define :term:`global parameters` of the scenario.
   * - :sampref:`require {boolean}`
     - Define a hard requirement.
   * - :sampref:`require[{number}] {boolean}`
     - Define a soft requirement.
   * - :sampref:`require {LTL formula}`
     - Define a dynamic hard requirement.
   * - :sampref:`require monitor {monitor}`
     - Define a dynamic requirement using a monitor.
   * - :sampref:`terminate when {boolean}`
     - Define a termination condition.
   * - :sampref:`terminate after {scalar} (seconds | steps)`
     - Set the scenario to terminate after a given amount of time.
   * - :sampref:`mutate {identifier}, {...} [by {number}]`
     - Enable mutation of the given list of objects.
   * - :sampref:`record [initial | final] {value} as {name}`
     - Save a value at every time step or only at the start/end of the simulation.

Dynamic Statements
++++++++++++++++++

These statements can only be used inside a :term:`dynamic behavior`, :term:`monitor`, or :keyword:`compose` block of a :term:`modular scenario`.

.. list-table::
   :header-rows: 1

   * - Syntax
     - Meaning
   * - :sampref:`take {action}, {...}`
     - Take the action(s) specified.
   * - :sampref:`wait`
     - Take no actions this time step.
   * - :sampref:`terminate`
     - Immediately end the scenario.
   * - :sampref:`terminate simulation`
     - Immediately end the entire simulation.
   * - :sampref:`do {behavior/scenario}, {...}`
     - Run one or more sub-behaviors/sub-scenarios until they complete.
   * - :sampref:`do {behavior/scenario}, {...} until {boolean}`
     - Run sub-behaviors/scenarios until they complete or a condition is met.
   * - :sampref:`do {behavior/scenario}, {...} for {scalar} (seconds | steps)`
     - Run sub-behaviors/scenarios for (at most) a specified period of time.
   * - :sampref:`do choose {behavior/scenario}, {...}`
     - Run *one* choice of sub-behavior/scenario whose preconditions are satisfied.
   * - :sampref:`do shuffle {behavior/scenario}, {...}`
     - Run several sub-behaviors/scenarios in a random order, satisfying preconditions.
   * - :sampref:`abort`
     - Break out of the current :keyword:`try-interrupt` statement.
   * - :sampref:`override {object} {specifier}, {...}`
     - Override properties of an object for the duration of the current scenario.

Objects
-------

The syntax :sampref:`new {class} {specifier}, {...} <objectCreate>` creates an instance of a Scenic class.

The Scenic class `Point` provides the basic position properties in the first table below; its subclass `OrientedPoint` adds the orientation properties in the second table.
Finally, the class `Object`, which represents physical objects and is the default superclass of user-defined Scenic classes, adds the properties in the third table.
See the :ref:`objects_and_classes` for details.

=======================  ==============  =============================================================================
   **Property**           **Default**                    **Meaning**
-----------------------  --------------  -----------------------------------------------------------------------------
 position [1]_           (0, 0, 0)       position in global coordinates
 visibleDistance         50              distance for the ‘can see’ operator
 viewRayDensity          5               determines ray count (if ray count is not provided)
 viewRayDistanceScaling  False           whether to scale number of rays with distance (if ray count is not provided)
 viewRayCount            None            tuple of number of rays to send in each dimension.
 mutationScale           0               overall scale of :ref:`mutations <mutate>`
 positionStdDev          (1,1,0)         mutation standard deviation for :prop:`position`
=======================  ==============  =============================================================================

Properties added by `OrientedPoint`:

===================  ==============  ================================================
   **Property**       **Default**                    **Meaning**
-------------------  --------------  ------------------------------------------------
 yaw [1]_             0              yaw in local coordinates
 pitch [1]_           0              pitch in local coordinates
 roll [1]_            0              roll in local coordinates
 parentOrientation    global         basis for local coordinate system
 viewAngles           (2π, π)        angles for visibility calculations
 orientationStdDev    (5°, 0, 0)     mutation standard deviation for :prop:`orientation`
===================  ==============  ================================================

Properties added by `Object`:

======================== ======================= ================================================
   **Property**           **Default**                       **Meaning**
------------------------ ----------------------- ------------------------------------------------
 width                   1                        width of bounding box (X axis)
 length                  1                        length of bounding box (Y axis)
 height                  1                        height of bounding box (Z axis)
 shape                   `BoxShape`               shape of the object
 allowCollisions         `False`                  whether collisions are allowed
 regionContainedIn       `workspace`              `Region` the object must lie within
 baseOffset              (0, 0, -self.height/2)   offset determining the base of the object
 contactTolerance        1e-4                     max distance to be considered on a surface
 sideComponentThresholds (-0.5, 0.5) per side     thresholds to determine side surfaces
 cameraOffset            (0, 0, 0)                position of camera for :keyword:`can see`
 requireVisible          `False`                  whether object must be visible from ego
 occluding               `True`                   whether object occludes visibility
 showVisibleRegion       `False`                  whether to display the visible region
 color                   None                     color of object
 velocity [1]_           from :prop:`speed`       initial (instantaneous) velocity
 speed [1]_              0                        initial (later, instantaneous) speed
 angularVelocity [1]_    (0, 0, 0)                initial (instantaneous) angular velocity
 angularSpeed [1]_       0                        angular speed (change in :prop:`heading`/time)
 behavior                `None`                   :term:`dynamic behavior`, if any
 lastActions             `None`                   tuple of actions taken in last timestamp
======================== ======================= ================================================

.. [1] These are :term:`dynamic properties`, updated automatically every time step during
    dynamic simulations.

Specifiers
----------

The :sampref:`with {property} {value}` specifier can specify any property, including new properties not built into Scenic.
Additional specifiers for the :prop:`position` and :prop:`orientation` properties are listed below.

.. figure:: images/Specifier_Figure.png
  :width: 60%
  :figclass: align-center
  :alt: Diagram illustrating several specifiers.

  Illustration of the :specifier:`beyond`, :specifier:`behind`, and :specifier:`offset by` specifiers.
  Each :scenic:`OrientedPoint` (e.g. ``P``) is shown as a bold arrow.

.. list-table::
   :header-rows: 1

   * - Specifier for :prop:`position`
     - Meaning
   * - :sampref:`at {vector}`
     - Positions the object at the given global coordinates
   * - :sampref:`in {region}`
     - Positions the object uniformly at random in the given Region
   * - :sampref:`contained in {region}`
     - Positions the object uniformly at random entirely contained in the given Region
   * - :sampref:`on {vector}`
     - Positions the base of the object at the given global coordinates
   * - :sampref:`on ({region} | {Object})`
     - Positions the object uniformly at random or modifies the position so that base of the Object is in the given Region/on the given Object.
   * - :sampref:`offset by {vector}`
     - Positions the object at the given coordinates in the local coordinate system of ego (which must already be defined)
   * - :sampref:`offset along {direction} by {vector}`
     - Positions the object at the given coordinates, in a local coordinate system centered at ego and oriented along the given direction
   * - :sampref:`beyond {vector} by ({vector} | {scalar}) [from ({vector} | {OrientedPoint})]`
     - Positions the object with respect to the line of sight from a point or the ego
   * - :sampref:`visible [from ({Point} | {OrientedPoint})]`
     - Ensures the object is visible from the ego, or from the given Point/OrientedPoint if given, while optionally specifying position to be uniformly random over all positions that result in a visible object.
   * - :sampref:`not visible [from ({Point} | {OrientedPoint})]`
     - Ensures the object is not visible from the ego, or from the given Point/OrientedPoint if given, while optionally specifying position to be uniformly random over all positions that result in a non-visible object.
   * - :sampref:`(left | right) of ({vector} | {OrientedPoint} | {Object}) [by {scalar}] <left of>`
     - Positions the object to the left/right by the given scalar distance.
   * - :sampref:`(ahead of | behind) ({vector} | {OrientedPoint} | {Object}) [by {scalar}] <ahead of>`
     - Positions the object to the front/back by the given scalar distance
   * - :sampref:`(above | below) ({vector} | {OrientedPoint} | {Object}) [by {scalar}] <above>`
     - Positions the object above/below by the given scalar distance
   * - :sampref:`following {vectorField} [from {vector}] for {scalar}`
     - Position by following the given vector field for the given distance starting from ego or the given vector


.. list-table::
   :header-rows: 1

   * - Specifier for :prop:`orientation`
     - Meaning
   * - :sampref:`facing {orientation}`
     - Orients the object along the given orientation in global coordinates
   * - :sampref:`facing {vectorField}`
     - Orients the object along the given vector field at the object’s position
   * - :sampref:`facing (toward | away from) {vector}`
     - Orients the object toward/away from the given position (thereby depending on the object’s position)
   * - :sampref:`facing directly (toward | away from) {vector}`
     - Orients the object *directly* toward/away from the given position (thereby depending on the object’s position)
   * - :sampref:`apparently facing {heading} [from {vector}]`
     - Orients the object so that it has the given heading with respect to the line of sight from ego (or the given vector)


Operators
---------

In the following tables, operators are grouped by the type of value they return.

.. figure:: images/Operator_Figure.png
  :width: 70%
  :figclass: align-center
  :alt: Diagram illustrating several operators.

  Illustration of several operators.
  Each :scenic:`OrientedPoint` (e.g. ``P``) is shown as a bold arrow.

.. list-table::
   :header-rows: 1

   * - Scalar Operators
     - Meaning
   * - :sampref:`relative heading of {heading} [from {heading}]`
     - The relative heading of the given heading with respect to ego (or the ``from`` heading)
   * - :sampref:`apparent heading of {OrientedPoint} [from {vector}]`
     -  The apparent heading of the `OrientedPoint`, with respect to the line of sight from ego (or the given vector)
   * - :sampref:`distance [from {vector}] to {vector}`
     - The distance to the given position from ego (or the ``from`` vector)
   * - :sampref:`angle [from {vector}] to {vector}`
     - The heading (azimuth) to the given position from ego (or the ``from`` vector)
   * - :sampref:`altitude [from {vector}] to {vector}`
     - The altitude to the given position from ego (or the ``from`` vector)

.. list-table::
   :header-rows: 1

   * - Boolean Operators
     - Meaning
   * - :sampref:`({Point} | {OrientedPoint}) can see ({vector} | {Object})`
     - Whether or not a position or `Object` is visible from a `Point` or `OrientedPoint`
   * - :sampref:`({vector} | {Object}) in {region}`
     - Whether a position or `Object` lies in the region
   * - :sampref:`({Object} | {region}) intersects ({Object} | {region})`
     - Whether an `Object`/`Region` intersects an `Object`/`Region`.


.. list-table::
   :header-rows: 1

   * - Orientation Operators
     - Meaning
   * - :sampref:`{scalar} deg`
     - The given angle, interpreted as being in degrees
   * - :sampref:`{vectorField} at {vector}`
     - The orientation specified by the vector field at the given position
   * - :sampref:`{direction} relative to {direction}`
     - The first direction (a heading, orientation, or vector field), interpreted as an offset relative to the second direction


.. list-table::
   :header-rows: 1

   * - Vector Operators
     - Meaning
   * - :sampref:`{vector} (relative to | offset by) {vector}`
     - The first vector, interpreted as an offset relative to the second vector (or vice versa)
   * - :sampref:`{vector} offset along {direction} by {vector}`
     - The second vector, interpreted in a local coordinate system centered at the first vector and oriented along the given direction


.. list-table::
   :header-rows: 1

   * - Region Operators
     - Meaning
   * - :sampref:`visible {region}`
     - The part of the given region visible from ego
   * - :sampref:`not visible {region}`
     - The part of the given region not visible from ego
   * - :sampref:`{region} visible from ({Point} | {OrientedPoint})`
     - The part of the given region visible from the given `Point` or `OrientedPoint`.
   * - :sampref:`{region} not visible from ({Point} | {OrientedPoint})`
     - The part of the given region not visible from the given `Point` or `OrientedPoint`.

.. list-table::
   :header-rows: 1

   * - OrientedPoint Operators
     - Meaning
   * - :sampref:`{vector} relative to {OrientedPoint}`
     - The given vector, interpreted in the local coordinate system of the OrientedPoint
   * - :sampref:`{OrientedPoint} offset by {vector}`
     - Equivalent to :scenic:`vector relative to OrientedPoint` above
   * - :sampref:`(front | back | left | right) of {Object}`
     - The midpoint of the corresponding side of the bounding box of the Object, inheriting the Object's orientation.
   * - :sampref:`(front | back) (left | right) of {Object}`
     - The midpoint of the corresponding edge of the bounding box of the Object, inheriting the Object's orientation.
   * - :sampref:`(front | back) (left | right) of {Object}`
     - The midpoint of the corresponding edge of the bounding box of the Object, inheriting the Object's orientation.
   * - :sampref:`(top | bottom) (front | back) (left | right) of {Object}`
     - The corresponding corner of the bounding box of the Object, inheriting the Object's orientation.

.. list-table::
   :header-rows: 1

   * - Temporal Operators
     - Meaning
   * - :sampref:`always {condition}`
     - Require the condition to hold at every time step.
   * - :sampref:`eventually {condition}`
     - Require the condition to hold at some time step.
   * - :sampref:`next {condition}`
     - Require the condition to hold in the next time step.
   * - :sampref:`{condition} until {condition}`
     - Require the first condition to hold until the second becomes true.
   * - :sampref:`{condition} implies {condition}`
     - Require the second condition to hold if the first condition holds.

Built-in Functions
------------------

.. list-table::
   :header-rows: 1

   * - Function
     - Description
   * - :ref:`Misc Python functions <gen_lifted_funcs>`
     - Various Python functions including :scenic:`min`, :scenic:`max`, :scenic:`open`, etc.
   * - :ref:`filter_func`
     - Filter a possibly-random list (allowing limited randomized control flow).
   * - :ref:`resample_func`
     - Sample a new value from a distribution.
   * - :ref:`localPath_func`
     - Convert a relative path to an absolute path, based on the current directory.
   * - :ref:`verbosePrint_func`
     - Like `print`, but silent at low-enough verbosity levels.
   * - :ref:`simulation_func`
     - Get the the current simulation object.


..  _syntax_details:
.. _language reference:

******************
Language Reference
******************

.. rubric:: Language Constructs

These pages describe the syntax of Scenic in detail.
For a one-page summary of Scenic's syntax, see the :doc:`syntax_guide`.
For details on the syntax for functions, loops, etc. inherited from Python, see the `Python Language Reference <https://docs.python.org/3/reference/index.html>`_.

.. toctree::
    :maxdepth: 1

    reference/general
    reference/data
    reference/region_types
    reference/distributions
    reference/statements
    reference/classes
    reference/specifiers
    reference/operators
    reference/functions
    reference/visibility

.. rubric:: Semantics and Scenario Generation

The pages above describe the semantics of each of Scenic's constructs individually; the following pages cover the semantics of entire Scenic programs, and how scenes and simulations are generated from them.

.. toctree::
    :maxdepth: 1

    reference/scene_generation
    reference/dynamic_scenarios



***********************
General Notes on Syntax
***********************

Keywords
========

.. rubric:: Keywords

The following words are reserved by Scenic and cannot be used as identifiers (i.e. as names of variables, functions, classes, properties, etc.).

.. literalinclude:: /_build/keywords.txt
    :language: text

.. rubric:: Soft Keywords

The following words have special meanings in Scenic in certain contexts, but are still available for use as identifiers.
Users should take care not to use these names when doing so would introduce ambiguity.
For example, consider the following code::

    distance = 5  # not a good variable name to use here
    new Object beyond A by distance from B

This might appear to use the three-argument form of the :keyword:`beyond` specifier, creating the new object at distance 5 beyond ``A`` from the point of view of ``B``.
But in fact Scenic parses the code as :specifier:`beyond A by (distance from B)`, because the interpretation of ``distance`` as being part of the :keyword:`distance from` operator takes precedence.

To avoid confusion, we recommend not using ``distance``, ``angle``, ``offset``, ``altitude``, or ``visible`` as identifiers in code that uses Scenic operators or specifiers (inside pure-Python helper functions is fine).

.. literalinclude:: /_build/keywords_soft.txt
    :language: text

.. rubric:: Builtin Names

The following names are built into Scenic and can be used but not overwritten .

.. literalinclude:: /_build/builtin_names.txt
    :language: text


..  _data:

***********************************
Data Types Reference
***********************************

This page describes the primitive data types built into Scenic.
In addition to these types, Scenic provides a class hierarchy for `points <Point>`, `oriented points <OrientedPoint>`, and `objects <Object>`: see the :ref:`objects_and_classes`.


.. _Boolean:

Boolean
=======

Booleans represent truth values, and can be `True` or `False`.

.. note::

	These are equivalent to the Python `bool` type.


.. _Scalar:

Scalar
======

Scalars represent distances, angles, etc. as floating-point numbers, which can be sampled from various distributions.

.. note::

	These are equivalent to the Python `float` type; however, any context which accepts a scalar will also allow an `int` or a NumPy numeric type such as `numpy.single` (to be precise, any instance of `numbers.Real` is legal).


.. _Vector:

Vector
======

Vectors represent positions and offsets in space.
They are constructed from coordinates using a length-3 list or tuple (:scenic:`[{X}, {Y}, {Z}]` or :scenic:`({X}, {Y}, {Z})`. Alternatively, they can be constructed with the syntax :scenic:`{X} @ {Y}` (inspired by `Smalltalk <http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf>`_) or a length-2 list or tuple, with an implied z value of 0.
By convention, coordinates are in meters, although the semantics of Scenic does not depend on this.

For convenience, instances of `Point` can be used in any context where a vector is expected: so for example if ``P`` is a `Point`, then :scenic:`P offset by (1, 2)` is equivalent to :scenic:`P.position offset by (1, 2)`.

.. versionchanged:: 3.0

    Vectors are now 3 dimensional.

.. _Heading:

Heading
=======
Headings represent yaw in the global XY plane.
Scenic represents headings in radians, measured anticlockwise from North, so that a heading of 0 is due North and a heading of π/2 is due West.
We use the convention that the heading of a local coordinate system is the heading of its Y-axis, so that, for example, the vector :scenic:`-2 @ 3` means 2 meters left and 3 ahead.

For convenience, instances of `OrientedPoint` can be used in any context where a heading is expected: so for example if ``OP`` is an `OrientedPoint`, then :scenic:`relative heading of OP` is equivalent to :scenic:`relative heading of OP.heading`.
Since `OrientedPoint` is a subclass of `Point`, expressions involving two oriented points like :scenic:`OP1 relative to OP2` can be ambiguous: the polymorphic operator :scenic:`relative to` accepts both vectors and headings, and either version could be meant here.
Scenic rejects such expressions as being ambiguous: more explicit syntax like :scenic:`OP1.position relative to OP2` must be used instead.

.. _Orientation:

Orientation
===========
Orientations represent orientations in 3D space.
Scenic represents orientations internally using quaternions, though for convenience they can be created using Euler angles. Scenic follows the right hand rule with the Z,X,Y order of rotations. In other words, Euler angles are given as (Yaw, Pitch, Roll), in radians, and applied in that order. To help visualize, one can consider their right hand with fingers extended orthogonally. The index finger points along positive X, the middle finger bends left along positive Y, and the thumb ends up pointing along positive Z. For rotations, align your right thumb with a positive axis and the way your fingers curl is a positive rotation.

.. versionadded:: 3.0

.. _Vector Field:
.. _VectorField:

Vector Field
============

Vector fields associate an orientation to each point in space.
For example, a vector field could represent the shortest paths to a destination, or the nominal traffic direction on a road (e.g. :obj:`scenic.domains.driving.model.roadDirection`).

.. versionchanged:: 3.0

    Vector fields now return an `Orientation` instead of a scalar heading.

.. _Region:

Region
======

Regions represent sets of points in space.
Scenic provides a variety of ways to define regions in 2D and 3D space: meshes, rectangles, circular sectors, line segments, polygons, occupancy grids, and explicit lists of points, among others.

Regions can have an associated vector field giving points in the region :term:`preferred orientations`.
For example, a region representing a lane of traffic could have a preferred orientation aligned with the lane, so that we can easily talk about distances along the lane, even if it curves.
Another possible use of preferred orientations is to give the surface of an object normal vectors, so that other objects placed on the surface face outward by default.

The main operations available for use with all regions are:

* the :sampref:`({vector} | {Object}) in {region}` operator to test containment within a region;
* the :sampref:`visible {region}` operator to get the part of a region which is visible from the :scenic:`ego`;
* the :sampref:`in {region}` specifier to choose a position uniformly at random inside a region;
* the :sampref:`on {region}` specifier to choose a position like :sampref:`in {region}` or to project an existing position onto the region's surface.

If you need to perform more complex operations on regions, or are writing a :term:`world model` and need to define your own regions, you will have to work with the :obj:`~scenic.core.regions.Region` class (which regions are instances of) and its subclasses for particular types of regions. These are listed in the :sampref:`Regions Types <region types>` reference. If you are working on Scenic's internals, see the :mod:`scenic.core.regions` module for full details.

.. _Shape:

Shape
=====

Shapes represent the shape of an object, i.e., the volume it occupies modulo translation, rotation, and scaling.
Shapes are represented by meshes, automatically converted to unit size and centered; Scenic considers the side of the shape facing the positive Y axis to be its front.

Shapes can be created from an arbitrary mesh or using one of the geometric primitives below.
For convenience, a shape created with specified dimensions will set the default dimensions for any `Object` created with that shape.
When creating a `MeshShape`, if no dimensions are provided then dimensions will be inferred from the mesh.
`MeshShape` also takes an optional ``initial_rotation`` parameter, which allows directions other than the positive Y axis to be considered the front of the shape.

.. autoclass:: scenic.core.shapes.MeshShape
    :noindex:
    :no-show-inheritance:
    :members: fromFile

.. autoclass:: scenic.core.shapes.BoxShape
    :noindex:
    :no-show-inheritance:

.. autoclass:: scenic.core.shapes.CylinderShape
    :noindex:
    :no-show-inheritance:

.. autoclass:: scenic.core.shapes.ConeShape
    :noindex:
    :no-show-inheritance:

.. autoclass:: scenic.core.shapes.SpheroidShape
    :noindex:
    :no-show-inheritance:



..  _region types:

***********************************
Region Types Reference
***********************************

This page covers the `scenic.core.regions.Region` class and its subclasses; for an introduction to the concept of regions in Scenic and the basic operations available for them, see :ref:`region`.

.. contents:: :local:

Abstract Regions
----------------

.. autoclass:: scenic.core.regions.Region
    :noindex:
    :no-show-inheritance:
    :no-members:
    :members: intersect, intersects, union

Point Sets and Lines
--------------------

.. autoclass:: scenic.core.regions.PointSetRegion
    :noindex:
    :no-show-inheritance:
    :no-members:

.. autoclass:: scenic.core.regions.PolylineRegion
    :noindex:
    :no-show-inheritance:
    :no-members:
    :members: start, end, signedDistanceTo, pointAlongBy, __getitem__, __len__


.. autoclass:: scenic.core.regions.PathRegion
    :noindex:
    :no-show-inheritance:
    :no-members:

.. _2D Regions:

2D Regions
----------

2D regions represent a 2D shape parallel to the XY plane, at a certain elevation in space. All 2D regions inherit from `PolygonalRegion`.

Unlike the more `PolygonalRegion`, the simple geometric shapes are allowed to depend on random values: for example, the :term:`visible region` of an `Object` is a `SectorRegion` based at the object's :prop:`position`, which might not be fixed.

Since 2D regions cannot contain an `Object` (which must be 3D), they define a :term:`footprint` for convenience.
Footprints are always a `PolygonalFootprintRegion`, which represents a 2D polygon extruded infinitely in the positive and negative vertical direction.
When checking containment of an `Object` in a 2D region, Scenic will atuomatically use the footprint.

.. autoclass:: scenic.core.regions.PolygonalRegion
    :noindex:
    :no-show-inheritance:
    :no-members:
    :members: boundary, footprint

.. autoclass:: scenic.core.regions.CircularRegion
    :noindex:
    :no-show-inheritance:
    :no-members:

.. autoclass:: scenic.core.regions.SectorRegion
    :noindex:
    :no-show-inheritance:
    :no-members:

.. autoclass:: scenic.core.regions.RectangularRegion
    :noindex:
    :no-show-inheritance:
    :no-members:

3D Regions
----------

3D regions represent points in 3D space.

Most 3D regions inherit from either `MeshVolumeRegion` or `MeshSurfaceRegion`, which represent the volume (of a watertight mesh) and the surface of a mesh respectively. Various region classes are also provided to create primitive shapes. `MeshVolumeRegion` can be converted to `MeshSurfaceRegion` (and vice versa) using the the ``getSurfaceRegion`` and ``getVolumeRegion`` methods.

PolygonalFootprintRegions represent the :term:`footprint` of a 2D region. See `2D Regions` for more details.

.. autoclass:: scenic.core.regions.MeshVolumeRegion
    :noindex:
    :no-members:
    :members: getSurfaceRegion, fromFile

.. autoclass:: scenic.core.regions.MeshSurfaceRegion
    :noindex:
    :no-members:
    :members: getVolumeRegion, fromFile

.. autoclass:: scenic.core.regions.BoxRegion
    :noindex:
    :no-show-inheritance:
    :no-members:

.. autoclass:: scenic.core.regions.SpheroidRegion
    :noindex:
    :no-show-inheritance:
    :no-members:

.. autoclass:: scenic.core.regions.PolygonalFootprintRegion
    :noindex:
    :no-show-inheritance:
    :no-members:

.. versionadded::3.0

Niche Regions
-------------

.. autoclass:: scenic.core.regions.GridRegion
    :noindex:
    :no-members:


..  _distributions:

***********************
Distributions Reference
***********************

Scenic provides functions for sampling from various types of probability distributions, and it is also possible to define custom types of distributions.

If you want to sample multiple times from the same distribution (for example if the distribution is passed as an argument to a helper function), you can use the `resample` function.


Built-in Distributions
======================

.. _Range({low}, {high}):

Range(*low*, *high*)
--------------------
Uniformly-distributed real number in the interval.

.. _DiscreteRange({low}, {high}):

DiscreteRange(*low*, *high*)
----------------------------
Uniformly-distributed integer in the (fixed) interval.

.. _Normal({mean}, {stdDev}):

Normal(*mean*, *stdDev*)
------------------------
Normal distribution with the given mean and standard deviation.

.. _TruncatedNormal({mean}, {stdDev}, {low}, {high}):

TruncatedNormal(*mean*, *stdDev*, *low*, *high*)
------------------------------------------------
Normal distribution as above, but truncated to the given window.

.. _Uniform({value}, {...}):

Uniform(*value*, ...)
---------------------
Uniform over a finite set of values. The Uniform distribution can also be used to uniformly select over a list of unknown length. This can be done using the unpacking operator (which supports distributions over lists) as follows: :scenic:`Uniform(*list)`.

.. _DiscreteDistr:

Discrete({*value*: *weight*, ... })
-----------------------------------
Discrete distribution over a finite set of values, with weights (which need not add up to 1).
Each value is sampled with probability proportional to its weight.

.. _uniform_in_region:

Uniform Distribution over a Region
----------------------------------
Scenic can also sample points uniformly at random from a `Region`, using the :sampref:`in {region}` and :sampref:`on {region}` specifiers.
Most subclasses of `Region` support random sampling.
A few regions, such as the `everywhere` region representing all space, cannot be sampled from since a uniform distribution over them does not exist.

Defining Custom Distributions
=============================

If necessary, custom distributions may be implemented by subclassing the `Distribution` class.
New subclasses must implement the :obj:`~scenic.core.distributions.Samplable.sampleGiven` method, which computes a random sample from the distribution given values for its dependencies (if any).
See :obj:`~scenic.core.distributions.Range` (the implementation of the uniform distribution over a range of real numbers) for a simple example of how to define a subclass.
Additional functionality can be enabled by implementing the optional `clone`, `bucket`, and :obj:`~scenic.core.distributions.Distribution.supportInterval` methods; see their documentation for details.


..  _statements:

***********************************
Statements Reference
***********************************

Compound Statements
===================

.. _classDef:

Class Definition
----------------

.. code-block:: scenic-grammar

    class <name>[(<superclass>)]:
        [<property>: <value>]*

Defines a Scenic class.
If a superclass is not explicitly specified, `Object` is used (see :ref:`objects_and_classes`).
The body of the class defines a set of properties its objects have, together with default values for each property.
Properties are inherited from superclasses, and their default values may be overridden in a subclass.
Default values may also use the special syntax :scenic:`self.{property}` to refer to one of the other properties of the same object, which is then a *dependency* of the default value.
The order in which to evaluate properties satisfying all dependencies is computed (and cyclic dependencies detected) during :ref:`specifier resolution`.

Scenic classes may also define attributes and methods in the same way as Python classes.

.. _behaviorDef:

Behavior Definition
--------------------

.. code-block:: scenic-grammar

    behavior <name>(<arguments>):
        [precondition: <boolean>]*
        [invariant: <boolean>]*
        <statement>+

Defines a :term:`dynamic behavior`, which can be assigned to a Scenic object by setting its :prop:`behavior` property using the :scenic:`with behavior {behavior}` specifier; this makes the object an :term:`agent`.
See our tutorial on :ref:`dynamics` for examples of how to write behaviors.

Behavior definitions have the same form as function definitions, with an argument list and a body consisting of one or more statements; the body may additionally begin with definitions of preconditions and invariants.
Preconditions are checked when a behavior is started, and invariants are checked at every time step of the simulation while the behavior is executing (including time step zero, like preconditions, but *not* including time spent inside sub-behaviors: this allows sub-behaviors to break and restore invariants before they return).

The body of a behavior executes in parallel with the simulation: in each time step, it must either :keyword:`take` specified action(s) or :keyword:`wait` and perform no actions.
After each :keyword:`take` or :keyword:`wait` statement, the behavior's execution is suspended, the simulation advances one step, and the behavior is then resumed.
It is thus an error for a behavior to enter an infinite loop which contains no :keyword:`take` or :keyword:`wait` statements (or :keyword:`do` statements invoking a sub-behavior; see below): the behavior will never yield control to the simulator and the simulation will stall.

Behaviors end naturally when their body finishes executing (or if they :scenic:`return`): if this happens, the agent performing the behavior will take no actions for the rest of the scenario.
Behaviors may also :keyword:`terminate` the current scenario, ending it immediately.

Behaviors may invoke sub-behaviors, optionally for a limited time or until a desired condition is met, using :keyword:`do` statements.
It is also possible to (temporarily) interrupt the execution of a sub-behavior under certain conditions and resume it later, using :ref:`try-interrupt <try>` statements.

.. _monitorDef:

Monitor Definition
------------------

.. code-block:: scenic-grammar

    monitor <name>(<arguments>):
        <statement>+

Defines a type of :term:`monitor`, which can be run in parallel with the simulation like a :term:`dynamic behavior`.
Monitors are not associated with an `Object` and cannot take actions, but can :keyword:`wait` to wait for the next time step (or use :keyword:`terminate` or :keyword:`terminate simulation` to end the scenario/simulation).
A monitor can be instantiated in a scenario with the :keyword:`require monitor` statement.

The main purpose of monitors is to evaluate complex temporal properties that are not expressible using the temporal operators available for :sampref:`require {LTL formula}` statements.
They can maintain state and use :keyword:`require` to enforce requirements depending on that state.
For examples of monitors, see our tutorial on :ref:`dynamics`.

.. versionchanged:: 3.0
    Monitors may take arguments, and must be explicitly instantiated using a :keyword:`require monitor` statement.

.. _modularScenarioDef:
.. _scenario-stmt:
.. _setup:
.. _compose:

Modular Scenario Definition 
---------------------------

.. code-block:: scenic-grammar

    scenario <name>(<arguments>):
        [precondition: <boolean>]*
        [invariant: <boolean>]*
        [setup:
            <statement>+]
        [compose:
            <statement>+]

.. code-block:: scenic-grammar

    scenario <name>(<arguments>):
        <statement>+

Defines a Scenic :term:`modular scenario`.
Scenario definitions, like :ref:`behavior definitions <behaviorDef>`, may include preconditions and invariants.
The body of a scenario consists of two optional parts: a ``setup`` block and a ``compose`` block.
The ``setup`` block contains code that runs once when the scenario begins to execute, and is a list of statements like a top-level Scenic program (so it may create objects, define requirements, etc.).
The ``compose`` block orchestrates the execution of sub-scenarios during a dynamic scenario, and may use :keyword:`do` and any of the other statements allowed inside behaviors (except :keyword:`take`, which only makes sense for an individual :term:`agent`).
If a modular scenario does not use preconditions, invariants, or sub-scenarios (i.e., it only needs a ``setup`` block) it may be written in the second form above, where the entire body of the ``scenario`` comprises the ``setup`` block.

.. seealso:: Our tutorial on :ref:`composition` gives many examples of how to use modular scenarios.

.. _tryInterruptStmt:
.. _try-interrupt:

Try-Interrupt Statement
-----------------------

.. code-block:: scenic-grammar

    try:
        <statement>+
    [interrupt when <boolean>:
        <statement>+]*
    [except <exception> [as <name>]:
        <statement>+]*

A ``try-interrupt`` statement can be placed inside a behavior (or :keyword:`compose` block of a :term:`modular scenario`) to run a series of statements, including invoking sub-behaviors with :keyword:`do`, while being able to interrupt at any point if given conditions are met.
When a ``try-interrupt`` statement is encountered, the statements in the ``try`` block are executed.
If at any time step one of the ``interrupt`` conditions is met, the corresponding ``interrupt`` block (its *handler*) is entered and run.
Once the interrupt handler is complete, control is returned to the statement that was being executed under the ``try`` block.

If there are multiple ``interrupt`` clauses, successive clauses take precedence over those which precede them; furthermore, during execution of an interrupt handler, successive ``interrupt`` clauses continue to be checked and can interrupt the handler.
Likewise, if ``try-interrupt`` statements are nested, the outermost statement takes precedence and can interrupt the inner statement at any time.
When one handler interrupts another and then completes, the original handler is resumed (and it may even be interrupted again before control finally returns to the ``try`` block).

The ``try-interrupt`` statement may conclude with any number of ``except`` blocks, which function identically to their :ref:`Python counterparts <except>` (though Scenic does not allow ``except*`` blocks).

Simple Statements
=================

The following statements can occur throughout a Scenic program unless otherwise stated.

.. _model {name}:
.. _model:

model *name*
------------
Select a :term:`world model` to use for this scenario.
The statement :scenic:`model {X}` is equivalent to :scenic:`from {X} import *` except that :scenic:`{X}` can be replaced using the :option:`--model` command-line option or the ``model`` keyword argument to the top-level APIs.
When writing simulator-agnostic scenarios, using the :scenic:`model` statement is preferred to a simple :scenic:`import` since a more specific world model for a particular simulator can then be selected at compile time.

.. _import {module}:
.. _import:

import *module*
----------------
Import a Scenic or Python module. This statement behaves :ref:`as in Python <import>`, but when importing a Scenic module it also imports any objects created and requirements imposed in that module.
Scenic also supports the form :scenic:`from {module} import {identifier}, {...}` , which as in Python imports the module plus one or more identifiers from its namespace.

.. _param {name} = {value}, {...}:
.. _param:

param *name* = *value*, . . .
---------------------------------------
Defines one or more :term:`global parameters` of the scenario.
These have no semantics in Scenic, simply having their values included as part of the generated `Scene`, but provide a general-purpose way to encode arbitrary global information.

If multiple :scenic:`param` statements define parameters with the same name, the last statement takes precedence, except that Scenic world models imported using the :keyword:`model` statement do not override existing values for global parameters.
This allows models to define default values for parameters which can be overridden by particular scenarios.
Global parameters can also be overridden at the command line using the :option:`--param` option, or from the top-level API using the ``params`` argument to `scenic.scenarioFromFile`.

To access global parameters within the scenario itself, you can read the corresponding attribute of the :scenic:`globalParameters` object.
For example, if you declare :scenic:`param weather = 'SUNNY'`, you could then access this parameter later in the program via :scenic:`globalParameters.weather`.
If the parameter was not overridden, this would evaluate to :scenic:`'SUNNY'`; if Scenic was run with the command-line option ``--param weather SNOW``, it would evaluate to :scenic:`'SNOW'` instead.

Some simulators provide global parameters whose names are not valid identifiers in Scenic.
To support giving values to such parameters without renaming them, Scenic allows the names of global parameters to be quoted strings, as in this example taken from an :ref:`X-Plane <xplane>` scenario::

    param simulation_length = 30
    param 'sim/weather/cloud_type[0]' = DiscreteRange(0, 5)
    param 'sim/weather/rain_percent' = 0

.. _require {boolean}:
.. _require:

require *boolean*
------------------
Defines a hard requirement, requiring that the given condition hold in all instantiations of the scenario.
This is equivalent to an "observe" statement in other probabilistic programming languages.

.. _require[{number}] {boolean}:
.. _soft-requirements:

require[*number*] *boolean*
---------------------------
Defines a soft requirement; like :keyword:`require` above but enforced only with the given probability, thereby requiring that the given condition hold with at least that probability (which must be a literal number, not an expression).
For example, :scenic:`require[0.75] ego in parking_lot` would require that the ego be in the parking lot at least 75% percent of the time.

.. _require {LTL formula}:

require *LTL formula*
---------------------
Defines a :term:`temporal requirement`, requiring that the given Linear Temporal Logic formula hold in a dynamic scenario.
See :ref:`temporal operators` for the list of supported LTL operators.

Note that an expression that does not use any temporal operators is evaluated only in the current time step.
So for example:

* :scenic:`require A and always B` will only require that ``A`` hold at time step zero, while ``B`` must hold at every time step (note that this is the same behavior you would get if you wrote :scenic:`require A` and :scenic:`require always B` separately);
* :scenic:`require (always A) implies B` requires that if ``A`` is true at every time step, then ``B`` must be true at time step zero;
* :scenic:`require always A implies B` requires that in *every* time step when ``A`` is true, ``B`` must also be true (since ``B`` is within the scope of the :keyword:`always` operator).

.. _require monitor {monitor}:
.. _require monitor:

require monitor *monitor*
-------------------------
Require a condition encoded by a :term:`monitor` hold during the scenario.
See :ref:`monitorDef` for how to define types of monitors.

It is legal to create multiple instances of a monitor with varying parameters.
For example::

    monitor ReachesBefore(obj1, region, obj2):
        reached = False
        while not reached:
            if obj1 in region:
                reached = True
            else:
                require obj2 not in region
                wait

    require monitor ReachesBefore(ego, goal, racecar2)
    require monitor ReachesBefore(ego, goal, racecar3)

.. _terminate when {boolean}:
.. _terminate when:

terminate when *boolean*
------------------------
Terminates the scenario when the provided condition becomes true.
If this statement is used in a :term:`modular scenario` which was invoked from another scenario, only the current scenario will end, not the entire simulation.

.. _terminate simulation when {boolean}:
.. _terminate simulation when:

terminate simulation when *boolean*
-----------------------------------
The same as :keyword:`terminate when`, except terminates the entire simulation even when used inside a sub-scenario (so there is no difference between the two statements when used at the top level).

.. _terminate after {scalar} (seconds | steps):
.. _terminate after:

terminate after *scalar* (seconds | steps)
------------------------------------------
Like :keyword:`terminate when` above, but terminates the scenario after the given amount of time.
The time limit can be an expression, but must be a non-random value.

.. _mutate {identifier}, {...} [by {number}]:
.. _mutate:

mutate *identifier*, . . . [by *scalar*]
-----------------------------------------
Enables mutation of the given list of objects (any `Point`, `OrientedPoint`, or `Object`), with an optional scale factor (default 1).
If no objects are specified, mutation applies to every `Object` already created.

The default mutation system adds Gaussian noise to the :prop:`position` and :prop:`heading` properties, with standard deviations equal to the scale factor times the :prop:`positionStdDev` and :prop:`headingStdDev` properties.

.. note::

    User-defined classes may specify custom mutators to allow mutation to apply to properties other than :prop:`position` and :prop:`heading`.
    This is done by providing a value for the :prop:`mutator` property, which should be an instance of `Mutator`.
    Mutators inherited from superclasses (such as the default :prop:`position` and :prop:`heading` mutators from `Point` and `OrientedPoint`) will still be applied unless the new mutator disables them; see `Mutator` for details.

.. _record [initial | final] {value} as {name}:
.. _record:
.. _record initial:
.. _record final:

record [initial | final] *value* [as *name*]
----------------------------------------------
Record the value of an expression during each simulation.
The value can be recorded at the start of the simulation (``initial``), at the end of the simulation (``final``), or at every time step (if neither ``initial`` nor ``final`` is specified).
The recorded values are available in the ``records`` dictionary of `SimulationResult`: its keys are the given names of the records (or synthesized names if not provided), and the corresponding values are either the value of the recorded expression or a tuple giving its value at each time step as appropriate.
For debugging, the records can also be printed out using the :option:`--show-records` command-line option.

Dynamic Statements
==================

The following statements are valid only in :term:`dynamic behaviors`, :term:`monitors`, and :keyword:`compose` blocks.

.. _take {action}, {...}:
.. _take:

take *action*, ...
------------------
Takes the action(s) specified and pass control to the simulator until the next time step.
Unlike :keyword:`wait`, this statement may not be used in monitors or :term:`modular scenarios`, since these do not take actions.

.. _wait:

wait
----
Take no actions this time step.

.. _terminate:

terminate
---------
Immediately end the scenario.
As for :keyword:`terminate when`, if this statement is used in a :term:`modular scenario` which was invoked from another scenario, only the current scenario will end, not the entire simulation.
Inside a :term:`behavior` being run by an agent, the "current scenario" for this purpose is the scenario which created the agent.

.. _terminate simulation:

terminate simulation
--------------------
Immediately end the entire simulation.

.. _do {behavior/scenario}, {...}:
.. _do:

do *behavior/scenario*, ...
-------------------------------
Run one or more sub-behaviors or sub-scenarios in parallel.
This statement does not return until all invoked sub-behaviors/scenarios have completed.

.. _do {behavior/scenario}, {...} until {boolean}:
.. _do-until:

do *behavior/scenario*, ... until *boolean*
-------------------------------------------
As above, except the sub-behaviors/scenarios will terminate when the condition is met.

.. _do {behavior/scenario}, {...} for {scalar} (seconds | steps):

do *behavior/scenario* for *scalar* (seconds | steps)
-----------------------------------------------------
Run sub-behaviors/scenarios for a set number of simulation seconds/time steps.
This statement can return before that time if all the given sub-behaviors/scenarios complete.

.. _do choose {behavior/scenario}, {...}:
.. _do choose:

do choose *behavior/scenario*, ...
----------------------------------
Randomly pick one of the given behaviors/scenarios whose preconditions are satisfied, and run it.
If no choices are available, the simulation is rejected.

This statement also allows the more general form :scenic:`do choose { {behaviorOrScenario}: {weight}, {...} }`, giving weights for each choice (which need not add up to 1).
Among all choices whose preconditions are satisfied, this picks a choice with probability proportional to its weight.

.. _do shuffle {behavior/scenario}, {...}:
.. _do shuffle:

do shuffle *behavior/scenario*, ...
-----------------------------------
Like :keyword:`do choose` above, except that when the chosen sub-behavior/scenario completes, a different one whose preconditions are satisfied is chosen to run next, and this repeats until all the sub-behaviors/scenarios have run once.
If at any point there is no available choice to run (i.e. we have a deadlock), the simulation is rejected.

This statement also allows the more general form :scenic:`do shuffle \{ {behaviorOrScenario}: {weight}, {...} }`, giving weights for each choice (which need not add up to 1).
Each time a new sub-behavior/scenario needs to be selected, this statement finds all choices whose preconditions are satisfied and picks one with probability proportional to its weight.

.. _abort:

abort
-----
Used in an interrupt handler to terminate the current :keyword:`try-interrupt` statement.

.. _override {object} {specifier}, {...}:
.. _override:

override *object* *specifier*, ...
------------------------------------
Override one or more properties of an object, e.g. its :prop:`behavior`, for the duration of the current scenario.
The properties will revert to their previous values when the current scenario terminates.
It is illegal to override :term:`dynamic properties`, since they are set by the simulator each time step and cannot be mutated manually.


..  _objects_and_classes:

*****************************
Objects and Classes Reference
*****************************

This page describes the classes built into Scenic, representing `points <Point>`, `oriented points <OrientedPoint>`, and physical `objects <Object>`, and how they are instantiated to create objects.

.. note::

    The documentation given here describes only the public properties and methods provided by the built-in classes.
    If you are working on Scenic's internals, you can find more complete documentation in the :mod:`scenic.core.object_types` module.

.. _objectCreate:
.. _new:

Instance Creation
-----------------

.. code-block:: scenic-grammar

    new <class> [<specifier> [, <specifier>]*]

Instantiates a Scenic object from a Scenic class.
The properties of the object are determined by the given set of zero or more specifiers.
For details on the available specifiers and how they interact, see the :ref:`specifiers`.

Instantiating an instance of `Object` has a side effect: the object is added to the scenario being defined.

.. versionchanged:: 3.0

    Instance creation now requires the ``new`` keyword. As a result, Scenic classes can be referred to without creating an instance.

Built-in Classes
----------------

..
    N.B. the following cross-reference target deliberately has the same name as the Point class.
    In 'conf.py' we introduce our own reference resolver for the :any: role which makes :ref: targets take precedence over :obj: targets normally, but the other way around when rendering a document in the 'modules' folder.
    This has the effect of making a cross-reference like `Point` in the main documentation link to the high-level description here, but the same reference in the auto-generated "Scenic Internals" section will instead link to the internal documentation for the Point class.

.. _Point:
.. _points:

Point
+++++

Locations in space.
This class provides the fundamental property :prop:`position` and several associated properties.

.. autoscenicclass:: scenic.core.object_types.Point
    :noindex:
    :no-show-inheritance:
    :no-members:
    :members: visibleRegion

.. _OrientedPoint:
.. _oriented points:

OrientedPoint
+++++++++++++

A location along with an orientation, defining a local coordinate system.
This class subclasses `Point`, adding the fundamental property :prop:`orientation` and several associated properties.

.. autoscenicclass:: scenic.core.object_types.OrientedPoint
    :noindex:
    :no-show-inheritance:
    :no-members:
    :members: visibleRegion

.. _Object:
.. _objects:

Object
++++++

A physical object.
This class subclasses `OrientedPoint`, adding a variety of properties including:

* :prop:`width`, :prop:`length`, and :prop:`height` to define the dimensions of the object;
* :prop:`shape` to define the `Shape` of the object;
* :prop:`allowCollisions`, :prop:`requireVisible`, and :prop:`regionContainedIn` to control the built-in requirements that apply to the object;
* :prop:`behavior`, specifying the object's :term:`dynamic behavior` if any;
* :prop:`speed`, :prop:`velocity`, and other properties capturing the dynamic state of the object during simulations.

The built-in requirements applying to each object are:

* The object must be completely contained within its :term:`container`, the region specified as its :prop:`regionContainedIn` property (by default the entire :term:`workspace`).
* The object must be visible from the ego object if the :prop:`requireVisible` property is set to `True` (default value `False`).
* The object must not intersect another object (i.e., their bounding boxes must not overlap), unless either of the two objects has their :prop:`allowCollisions` property set to `True`.

.. versionchanged:: 3.0

    :prop:`requireVisible` is now `False` by default.

.. autoscenicclass:: scenic.core.object_types.Object
    :noindex:
    :no-show-inheritance:
    :no-members:
    :members: startDynamicSimulation, visibleRegion



..  _specifiers:

********************
Specifiers Reference
********************

Specifiers are used to define the properties of an object when a Scenic class is :ref:`instantiated <objectCreate>`.
This page describes all the specifiers built into Scenic, and the procedure used to :ref:`resolve <specifier resolution>` a set of specifiers into an assignment of values to properties.

Each specifier assigns values to one or more properties of an object, as a function of the arguments of the specifier and possibly other properties of the object assigned by other specifiers.
For example, the :specifier:`left of {X} by {Y}` specifier assigns the :prop:`position` property of the object being defined so that the object is a distance :scenic:`{Y}` to the left of :scenic:`{X}`: this requires knowing the :prop:`width` of the object first, so we say the :specifier:`left of` specifier **specifies** the :prop:`position` property and **depends** on the :prop:`width` property.

In fact, the :specifier:`left of` specifier also specifies the :prop:`parentOrientation` property (to be the :prop:`orientation` of :scenic:`{X}`), but it does this with a lower **priority**.
Multiple specifiers can specify the same property, but only the specifier that specifies the property with the highest priority is used.
If a property is specified multiple times with the same priority, an ambiguity error is raised.
We represent priorities as integers, with priority 1 being the highest and larger integers having progressively lower priorities (e.g. priority 2 supersedes priority 3).
When a specifier specifies a property with a priority lower than 1, we say it **optionally** specifies the property, since it can be overridden (for example using the :specifier:`with` specifier), whereas a specifier specifying the property with priority 1 cannot be overridden.

Certain specifiers can also *modify* already-specified values.
These **modifying specifiers** do not cause an ambiguity error as above if another specifier specifies the same property with the same priority: they take the already-specified value and manipulate it in some way (potentially also specifying other properties as usual).
Note that no property can be modified twice.
The only modifying specifier currently in Scenic is :specifier:`on {region}`, which can be used either as a standard specifier or a modifying specifier (the modifying version projects the already-specified position onto the given region -- see below).

The :ref:`specifier resolution` process works out which specifier determines each property of an object, as well as an appropriate order in which to evaluate the specifiers so that dependencies have already been computed when needed.

General Specifiers
==================

.. _with {property} {value}:

with *property* *value*
-----------------------

**Specifies**:

	* the given property, with priority 1

**Dependencies**: None

Assigns the given property to the given value.
This is currently the only specifier available for properties other than :prop:`position` and :prop:`orientation`.


Position Specifiers
===================

.. figure:: ../images/Specifier_Figure.png
  :width: 60%
  :figclass: align-center
  :alt: Diagram illustrating several specifiers.

  Illustration of the :specifier:`beyond`, :specifier:`behind`, and :specifier:`offset by` specifiers.
  Each :scenic:`OrientedPoint` (e.g. ``P``) is shown as a bold arrow.

.. _at {vector}:

at *vector*
-----------

**Specifies**:

	* :prop:`position` with priority 1

**Dependencies**: None

Positions the object at the given global coordinates.

.. _in {region}:
.. _in:

in *region*
-----------

**Specifies**:

	* :prop:`position` with priority 1
	* :prop:`parentOrientation` with priority 3 (if the region has a :term:`preferred orientation`)

**Dependencies**: None


Positions the object uniformly at random in the given `Region`.
If the Region has a :term:`preferred orientation` (a vector field), also specifies :prop:`parentOrientation` to be equal to that orientation at the object’s :prop:`position`.

.. _contained in {region}:

contained in *region*
---------------------

**Specifies**:

	* :prop:`position` with priority 1
	* :prop:`regionContainedIn` with priority 1
	* :prop:`parentOrientation` with priority 3 (if the region has a :term:`preferred orientation`)

**Dependencies**: None

Like :sampref:`in {region}`, but also enforces that the object be entirely contained in the given `Region`.

.. _on {region}:
.. _on ({region} | {Object}):
.. _on ({region} | {Object} | {vector}):
.. _on {vector}:
.. _on:

on (*region* | *Object* | *vector*)
-----------------------------------

**Specifies**:

	* :prop:`position` with priority 1; **modifies** existing value, if any
	* :prop:`parentOrientation` with priority 2 (if the region has a :term:`preferred orientation`)

**Dependencies**: :prop:`baseOffset` • :prop:`contactTolerance` • :prop:`onDirection`

If :prop:`position` is not already specified with priority 1, positions the *base* of the object uniformly at random in the given `Region`, on the :prop:`onSurface` of the given `Object`, or with the base of the object at the given vector. The position is always offset by half of :prop:`contactTolerance` (to avoid a collision).
The base of the object is determined by adding the object's :prop:`baseOffset` to its :prop:`position`.

If instead :prop:`position` has already been specified with priority 1, then its value is modified by projecting it onto the given region (or the :prop:`onSurface` of the given object). Note that this modifying version of the specifier does not accept a vector.
More precisely, we find the closest point in the region along :prop:`onDirection` (or its negation [1]_), and place the base of the object at that point. If :prop:`onDirection` is not specified, a default value is inferred from the region. A region can either specify a default value to be used, or for volumes straight up is used and for surfaces the mean of the face normal values is used (weighted by the area of the faces).

If the region has a :term:`preferred orientation` (a vector field), :prop:`parentOrientation` is specified to be equal to that orientation at the object’s :prop:`position` (whether or not this specifier is being used as a modifying specifier).
Note that this is done with higher priority than all other specifiers which optionally specify :prop:`parentOrientation`, and in particular the :specifier:`ahead of` specifier and its variants: therefore the code :scenic:`new Object ahead of taxi by 100, on road` aligns the new object with the road at the point 100 m ahead of the taxi rather than with the taxi itself (while also using projection to ensure the new object is on the surface of the road rather than under or over it if the road isn't flat).

.. [1] This allows for natural projection even when an object is below the desired surface, such as placing a car, ahead of another car, on an uphill road.

.. _offset by {vector}:

offset by *vector*
------------------

**Specifies**:

	* :prop:`position` with priority 1
	* :prop:`parentOrientation` with priority 3

**Dependencies**: None

Positions the object at the given coordinates in the local coordinate system of :scenic:`ego` (which must already be defined).
Also specifies :prop:`parentOrientation` to be equal to the ego's orientation.

.. versionadded:: 3.0
	:specifier:`offset by` now specifies :prop:`parentOrientation`, whereas previously it did *not* optionally specify :prop:`heading`.

.. _offset along {direction} by {vector}:

offset along *direction* by *vector*
------------------------------------

**Specifies**:

	* :prop:`position` with priority 1
	* :prop:`parentOrientation` with priority 3

**Dependencies**: None

Positions the object at the given coordinates in a local coordinate system centered at :scenic:`ego` and oriented along the given direction (which can be a `heading`, an `orientation`, or a `vector field`).
Also specifies :prop:`parentOrientation` to be equal to the ego's orientation.

.. _beyond {vector} by ({vector} | {scalar}) [from ({vector} | {OrientedPoint})]:
.. _beyond:

beyond *vector* by (*vector* | *scalar*) [from (*vector* | *OrientedPoint*)]
----------------------------------------------------------------------------

**Specifies**:

	* :prop:`position` with priority 1
	* :prop:`parentOrientation` with priority 3

**Dependencies**: None

Positions the object at coordinates given by the second vector, in a local coordinate system centered at the first vector and oriented along the line of sight from the third vector (i.e. an orientation of :scenic:`(0,0,0)` in the local coordinate system faces directly away from the third vector).
If the second argument is a scalar :scenic:`{D}` instead of a vector, it is interpreted as the vector :scenic:`(0, {D}, 0)`: thus :specifier:`beyond {X} by {D} from {Y}` places the new object a distance of :scenic:`{D}` behind :scenic:`{X}` from the perspective of :scenic:`{Y}`.
If no third argument is provided, it is assumed to be the :scenic:`ego`.

The value of :prop:`parentOrientation` is specified to be the orientation of the third argument if it is an `OrientedPoint` (including `Objects` such as :scenic:`ego`); otherwise the global coordinate system is used.
For example, :specifier:`beyond taxi by (1, 3, 0)` means 3 meters behind the taxi and one meter to the right as viewed by the :scenic:`ego`.

.. _visible [from ({Point} | {OrientedPoint})]:
.. _visible_spec:

visible [from (*Point* | *OrientedPoint*)]
------------------------------------------

**Specifies**:

	* :prop:`position` with priority 3
	* also adds a requirement (see below)

**Dependencies**: :prop:`regionContainedIn`

Requires that this object is visible from the :scenic:`ego` or the given `Point`/`OrientedPoint`. See the :ref:`Visibility System <visibility>` reference for a discussion of the visibility model.

Also optionally specifies :prop:`position` to be uniformly random over all points that could result in a visible object (note that the above requirement will ensure the object is in fact visible).

.. versionchanged:: 3.0

	This specifier now specifies :prop:`position` uniformly randomly over all points that could result in a visible object. This allows for objects whose :prop:`position` might be out of the visible region, but which have a portion of their occupied space visible (e.g. a corner that is visible). With the previous semantics, such configurations would never be generated because the *center* of the object was required to be visible.

.. note::
	
	As an implementation detail, :prop:`position` is initially set to be sampled from `everywhere` (or the :term:`workspace` if one has been set). Scenic will then attempt to further restrict the sample region via various pruning techniques, but sometimes this is not possible. If this occurs and Scenic has not been able to further restrict the sampled region from `everywhere`, an error will be raised at compile time. The simplest way to remedy this is by setting a workspace or specifying :prop:`position` with a higher priority using a different specifier.

.. _not visible [from ({Point} | {OrientedPoint})]:

not visible [from (*Point* | *OrientedPoint*)]
----------------------------------------------

**Specifies**:

	* :prop:`position` with priority 3
	* also adds a requirement (see below)

**Dependencies**: :prop:`regionContainedIn`

Requires that this object is *not* visible from the ego or the given `Point`/`OrientedPoint`.

Similarly to :sampref:`visible [from ({Point} | {OrientedPoint})]`, this specifier can optionally position the object uniformly at random over all points that could result in a non-visible object (note that the above requirement will ensure the object is in fact not visible).

.. versionchanged:: 3.0

	This specifier now specifies :prop:`position` uniformly randomly over all points that could result in a non-visible object. This disallows objects whose :prop:`position` is out of the visible region, but which have a portion of their occupied space visible (e.g. a corner that is visible). With the previous semantics, such configurations would sometimes be generated because only the *center* of the object was required to be non-visible.

.. _(left | right) of {vector} [by {scalar}]:
.. _left of:
.. _right of:

(left | right) of (*vector*) [by *scalar*]
------------------------------------------

**Specifies**:

	* :prop:`position` with priority 1

**Dependencies**: :prop:`width` • :prop:`orientation`


Without the optional :scenic:`by {scalar}`, positions the object immediately to the left/right of the given position; i.e., so that the midpoint of the right/left side of the object's bounding box is at that position.
If :scenic:`by {scalar}` is used, the object is placed further to the left/right by the given distance.

.. _(left | right) of {OrientedPoint} [by {scalar}]:

(left | right) of *OrientedPoint* [by *scalar*]
-----------------------------------------------

**Specifies**:

	* :prop:`position` with priority 1
	* :prop:`parentOrientation` with priority 3

**Dependencies**: :prop:`width`

Positions the object to the left/right of the given `OrientedPoint`.
Also inherits :prop:`parentOrientation` from the given `OrientedPoint`.

.. _(left | right) of {Object} [by {scalar}]:
.. _left of {Object}:

(left | right) of *Object* [by *scalar*]
----------------------------------------

**Specifies**:

	* :prop:`position` with priority 1
	* :prop:`parentOrientation` with priority 3

**Dependencies**: :prop:`width` • :prop:`contactTolerance`

Positions the object to the left/right of the given `Object`.
This accounts for both objects' dimensions, placing them so that the distance between their bounding boxes is exactly the desired scalar distance (or :prop:`contactTolerance` if :scenic:`by {scalar}` is not used).
Also inherits :prop:`parentOrientation` from the given `OrientedPoint`.

.. _(ahead of | behind) ({vector} | {Point}) [by {scalar}]:
.. _ahead of:
.. _behind:

(ahead of | behind) *vector* [by *scalar*]
------------------------------------------

**Specifies**:

	* :prop:`position` with priority 1

**Dependencies**: :prop:`length` • :prop:`orientation`


Without the optional :scenic:`by {scalar}`, positions the object immediately ahead of/behind the given position; i.e., so that the midpoint of the front/back side of the object’s bounding box is at that position.
If :scenic:`by {scalar}` is used, the object is placed further ahead/behind by the given distance.

.. _(ahead of | behind) {OrientedPoint} [by {scalar}]:

(ahead of | behind) *OrientedPoint* [by *scalar*]
-------------------------------------------------

**Specifies**:

	* :prop:`position` with priority 1
	* :prop:`parentOrientation` with priority 3

**Dependencies**: :prop:`length`

Positions the object ahead of/behind the given `OrientedPoint`.
Also inherits :prop:`parentOrientation` from the given `OrientedPoint`.

.. _(ahead of | behind) {Object} [by {scalar}]:

(ahead of | behind) *Object* [by *scalar*]
------------------------------------------

**Specifies**:

	* :prop:`position` with priority 1
	* :prop:`parentOrientation` with priority 3

**Dependencies**: :prop:`length` • :prop:`contactTolerance`

Positions the object ahead of/behind the given `Object`.
This accounts for both objects' dimensions, placing them so that the distance between their bounding boxes is exactly the desired scalar distance (or :prop:`contactTolerance` if :scenic:`by {scalar}` is not used).
Also inherits :prop:`parentOrientation` from the given `OrientedPoint`.

.. _(above | below) {vector} [by {scalar}]:
.. _above:
.. _below:

(above | below) *vector* [by *scalar*]
--------------------------------------

**Specifies**:

	* :prop:`position` with priority 1

**Dependencies**: :prop:`height` • :prop:`orientation`


Without the optional :scenic:`by {scalar}`, positions the object immediately above/below the given position; i.e., so that the midpoint of the top/bottom side of the object’s bounding box is at that position.
If :scenic:`by {scalar}` is used, the object is placed further above/below by the given distance.

.. _(above | below) {OrientedPoint} [by {scalar}]:

(above | below) *OrientedPoint* [by *scalar*]
---------------------------------------------

**Specifies**:

	* :prop:`position` with priority 1
	* :prop:`parentOrientation` with priority 3

**Dependencies**: :prop:`height`

Positions the object above/below the given `OrientedPoint`.
Also inherits :prop:`parentOrientation` from the given `OrientedPoint`.

.. _(above | below) {Object} [by {scalar}]:

(above | below) *Object* [by *scalar*]
--------------------------------------

**Specifies**:

	* :prop:`position` with priority 1
	* :prop:`parentOrientation` with priority 3

**Dependencies**: :prop:`height` • :prop:`contactTolerance`

Positions the object above/below the given `Object`.
This accounts for both objects' dimensions, placing them so that the distance between their bounding boxes is exactly the desired scalar distance (or :prop:`contactTolerance` if :scenic:`by {scalar}` is not used).
Also inherits :prop:`parentOrientation` from the given `OrientedPoint`.

.. _following {vectorField} [from {vector}] for {scalar}:

following *vectorField* [from *vector*] for *scalar*
----------------------------------------------------

**Specifies**:

	* :prop:`position` with priority 1
	* :prop:`parentOrientation` with priority 3

**Dependencies**: None

Positions the object at a point obtained by following the given `vector field` for the given distance starting from :scenic:`ego` (or the position optionally provided with :scenic:`from {vector}`).
Specifies :prop:`parentOrientation` to be the orientation of the vector field at the resulting point.

.. note::

  This specifier uses a forward Euler approximation of the continuous vector field.
  The choice of step size can be customized for individual fields: see the documentation
  of `VectorField`. If necessary, you can also call the underlying method
  `VectorField.followFrom`  directly.


Orientation Specifiers
======================

.. _facing {orientation}:

facing *orientation*
--------------------

**Specifies**:

	* :prop:`yaw` with priority 1
	* :prop:`pitch` with priority 1
	* :prop:`roll` with priority 1

**Dependencies**: :prop:`parentOrientation`


Sets the object's :prop:`yaw`, :prop:`pitch`, and :prop:`roll` so that its orientation in global coordinates is equal to the given orientation.
If a single scalar is given, it is interpreted as a `heading`: so for example :specifier:`facing 45 deg` orients the object in the XY plane, facing northwest.
If a triple of scalars is given, it is interpreted as a triple of global Euler angles: so for example :specifier:`facing (45 deg, 90 deg, 0)` would orient the object to face northwest as above but then apply a 90° pitch upwards.

.. _facing {vectorField}:

facing *vectorField*
--------------------

**Specifies**:

	* :prop:`yaw` with priority 1
	* :prop:`pitch` with priority 1
	* :prop:`roll` with priority 1

**Dependencies**: :prop:`position` • :prop:`parentOrientation`

Sets the object's :prop:`yaw`, :prop:`pitch`, and :prop:`roll` so that its orientation in global coordinates is equal to the orientation provided by the given `vector field` at the object’s :prop:`position`.

.. _facing (toward | away from) {vector}:

facing (toward | away from) *vector*
------------------------------------

**Specifies**:

	* :prop:`yaw` with priority 1

**Dependencies**: :prop:`position` • :prop:`parentOrientation`

Sets the object's :prop:`yaw` so that it faces toward/away from the given position (thereby depending on the object’s :prop:`position`).

.. _facing directly (toward | away from) {vector}:

facing directly (toward | away from) *vector*
---------------------------------------------

**Specifies**:

	* :prop:`yaw` with priority 1
	* :prop:`pitch` with priority 1

**Dependencies**: :prop:`position` • :prop:`parentOrientation`

Sets the object's :prop:`yaw` *and* :prop:`pitch` so that it faces directly toward/away from the given position (thereby depending on the object’s :prop:`position`).


.. _apparently facing {heading} [from {vector}]:

apparently facing *heading* [from *vector*]
-------------------------------------------

**Specifies**:

	* :prop:`yaw` with priority 1

**Dependencies**: :prop:`position` • :prop:`parentOrientation`

Sets the :prop:`yaw` of the object so that it has the given heading with respect to the line of sight from :scenic:`ego` (or the ``from`` vector).
For example, if the :scenic:`ego` is in the XY plane, then :specifier:`apparently facing 90 deg` orients the new object so that the ego's camera views its left side head-on.

.. _specifier resolution:

Specifier Resolution
====================

Specifier resolution is the process of determining, given the set of specifiers used to define an object, which properties each specifier should determine and what order to evaluate the specifiers in.
As each specifier can specify multiple properties with various priorities, and can depend on the results of other specifiers, this process is somewhat non-trivial.
Assuming there are no cyclic dependencies or conflicts, the process will conclude with each property being determined by its unique highest-priority specifier if one exists (possibly modified by a modifying specifier), and otherwise by its default value, with default values from subclasses overriding those in superclasses.

The full procedure, given a set of specifiers *S* used to define an instance of class *C*, works as follows:

1. If a property is specified at the same priority level by multiple specifiers in *S*, an ambiguity error is raised.
2. The set of properties *P* for the new object is found by combining the properties specified by all members of *S* with the properties inherited from the class *C*.
3. Default value specifiers from *C* (or if not overridden, from its superclasses) are added to *S* as needed so that each property in *P* is paired with a unique non-modifying specifier in *S* specifying it (taking the highest-priority specifier, if there are multiple), plus up to one modifying specifier modifying it.
4. The dependency graph of the specifiers *S* is constructed (with edges from each specifier to the others which depend on its results). If it is cyclic, an error is raised.
5. The graph is topologically sorted and the specifiers are evaluated in this order to determine the values of all properties *P* of the new object.


..  _operators:

*******************
Operators Reference
*******************

.. figure:: ../images/Operator_Figure.png
  :width: 70%
  :figclass: align-center
  :alt: Diagram illustrating several operators.

  Illustration of several operators.
  Each :scenic:`OrientedPoint` (e.g. ``P``) is shown as a bold arrow.


Scalar Operators
=================

.. _relative heading of {heading} [from {heading}]:

relative heading of *heading* [from *heading*]
----------------------------------------------
The relative heading of the given heading with respect to ego (or the heading provided with the optional from heading)

.. _apparent heading of {OrientedPoint} [from {vector}]:

apparent heading of *OrientedPoint* [from *vector*]
---------------------------------------------------
The apparent heading of the OrientedPoint, with respect to the line of sight from ego (or the position provided with the optional from vector)

.. _distance [from {vector}] to {vector}:
.. _distance from:

distance [from *vector*] to *vector*
-------------------------------------
The distance to the given position from ego (or the position provided with the optional from vector)

.. _angle [from {vector}] to {vector}:

angle [from *vector* ] to *vector*
----------------------------------
The heading (azimuth) to the given position from ego (or the position provided with the optional from vector). For example, if angle to taxi is zero, then taxi is due North of ego

.. _altitude [from {vector}] to {vector}:

altitude [from *vector* ] to *vector*
-------------------------------------
The altitude to the given position from ego (or the position provided with the optional from vector ). For example, if altitude to plane is π, then plane is directly above ego.



Boolean Operators
==================

.. _({Point} | {OrientedPoint}) can see ({vector} | {Object}):
.. _can see:

(*Point* | *OrientedPoint*) can see (*vector* | *Object*)
---------------------------------------------------------
Whether or not a position or `Object` is visible from a `Point` or `OrientedPoint`, accounting for occlusion.

See the :ref:`Visibility System <visibility>` reference for a discussion of the visibility model.

.. _({vector} | {Object}) in {region}:

(*vector* | *Object*) in *region*
----------------------------------
Whether a position or `Object` lies in the `Region`; for the latter, the object must be completely contained in the region.

.. _({Object} | {region}) intersects ({Object} | {region}):

(*Object* | *region*) intersects (*Object* | *region*)
------------------------------------------------------
Whether an `Object`/`Region` intersects another `Object`/`Region`, i.e. whether any portion of the occupied spaces intersect.

When working with 2D regions, it can be useful to check intersection with the :term:`footprint` of a region, e.g. when checking whether a car intersects a given lane. In this case, one would write :scenic:`car intersects lane.footprint` instead of :scenic:`car intersects lane`. For more details, see :term:`footprint`.


Orientation Operators
=====================

.. _{scalar} deg:

*scalar* deg
------------
The given angle, interpreted as being in degrees. For example 90 deg evaluates to π/2

.. _{vectorField} at {vector}:

*vectorField* at *vector*
-------------------------
The orientation specified by the vector field at the given position

.. _{direction} relative to {direction}:

(*direction*) relative to (*direction*)
-------------------------------------------------------------------
The orientation obtained by starting in the second direction and then rotating according to the first direction. For example, :scenic:`-5 deg relative to 90 deg` is simply 85 degrees. If either direction is a vector field, then this operator yields an expression depending on the :prop:`position` property of the object being specified. Both operator values must be of type `heading`, `Orientation`, or `vectorField`, not tuples, as tuples are by default intepreted as `Vector` objects.

.. note::
	This operator is not necessarily commutative, for example, when composing two 3D orientations.


Vector Operators
================

.. _{vector} (relative to | offset by) {vector}:

*vector* (relative to | offset by) *vector*
--------------------------------------------
The first vector, interpreted as an offset relative to the second vector (or vice versa).
For example, :scenic:`(5, 5, 5) relative to (100, 200, 300)` is :scenic:`(105, 205, 305)`.
Note that this polymorphic operator has a specialized version for instances of `OrientedPoint`, defined :ref:`below <{vector} relative to {OrientedPoint}>`: so for example :scenic:`(-3, 0, 0) relative to taxi` will not use the version of this operator for vectors (even though the `Object` taxi can be coerced to a vector).

.. _{vector} offset along {direction} by {vector}:

*vector* offset along *direction* by *vector*
----------------------------------------------
The second vector, interpreted in a local coordinate system centered at the first vector and oriented along the given direction (which, if a vector field, is evaluated at the first vector to obtain an orientation)

Region Operators
================

.. _visible {region}:

visible *region*
----------------
The part of the given region which is visible from the ego object (i.e. the intersection of the given region with the :term:`visible region` of the ego).

.. _not visible {region}:

not visible *region*
--------------------
The part of the given region which is *not* visible from the ego object (as above, based on the ego's :term:`visible region`).

.. _{region} visible from ({Point} | {OrientedPoint}):

*region* visible from (*Point* | *OrientedPoint*)
-------------------------------------------------
The part of the given region visible from the given `Point` or `OrientedPoint` (like :scenic:`visible {region}` but from an arbitrary `Point`/`OrientedPoint`).

.. _{region} not visible from ({Point} | {OrientedPoint}):

*region* not visible from (*Point* | *OrientedPoint*)
------------------------------------------------------
The part of the given region not visible from the given `Point` or `OrientedPoint` (like :scenic:`not visible {region}` but from an arbitrary `Point`/`OrientedPoint`).

OrientedPoint Operators
=======================

.. _{vector} relative to {OrientedPoint}:

*vector* relative to *OrientedPoint*
-------------------------------------
The given vector, interpreted in the local coordinate system of the OrientedPoint. So for example :scenic:`(1, 2, 0) relative to ego` is 1 meter to the right and 2 meters ahead of ego.

.. _{OrientedPoint} offset by {vector}:

*OrientedPoint* offset by *vector*
----------------------------------
Equivalent to :scenic:`{vector} relative to {OrientedPoint}` above

.. _(front | back | left | right) of {Object}:

(front | back | left | right | top | bottom) of *Object*
--------------------------------------------------------
The midpoint of the corresponding side of the bounding box of the `Object`, inheriting the Object's orientation.

.. _(front | back) (left | right) of {Object}:

(front | back) (left | right) of *Object*
-----------------------------------------
The midpoint of the corresponding edge of the Object’s bounding box, inheriting the Object's orientation.


.. _(top | bottom) (front | back) (left | right) of {Object}:

(top | bottom) (front | back) (left | right) of *Object*
--------------------------------------------------------
The corresponding corner of the Object’s bounding box, inheriting the Object's orientation.

.. _temporal operators:

Temporal Operators
=======================

Temporal operators can be used inside :keyword:`require` statements to constrain how a dynamic scenario evolves over time.
The semantics of these operators are taken from Linear Temporal Logic (specifically, we use RV-LTL [B10]_ to properly model the finite length of Scenic simulations).

.. _always {condition}:
.. _always:

always *condition*
------------------
Require the given condition to hold throughout the execution of the dynamic scenario.

.. _eventually {condition}:
.. _eventually:

eventually *condition*
----------------------
Require the given condition to hold at some point during the execution of the dynamic scenario.

.. _next {condition}:
.. _next:

next *condition*
----------------
Require the given condition to hold at the next time step of the dynamic scenario.

For example, while :scenic:`require X` requires that ``X`` hold at time step 0 (the start of the simulation), :scenic:`require next X` requires that ``X`` hold at time step 1.
The requirement :scenic:`require always (X implies next X)` says that for every time step :math:`N`, if ``X`` is true at that time step then it is also true at step :math:`N+1`; equivalently, if ``X`` ever becomes true, it must remain true for the rest of the simulation.

.. _{condition} until {condition}:
.. _until:

*condition* until *condition*
-----------------------------
Require the second condition to hold at some point, and the first condition to hold at every time step before then (after which it is unconstrained).

Note that this is the so-called *strong until*, since it requires the second condition to eventually become true.
For the *weak until*, which allows the second condition to never hold (in which case the first condition must *always* hold), you can write :scenic:`require ({X} until {Y}) or (always {X} and not {Y})`.

.. _{condition} implies {condition}:
.. _implies:

*hypothesis* implies *conclusion*
---------------------------------
Require the conclusion to hold if the hypothesis holds.

This is syntactic sugar for :scenic:`not {hypothesis} or {conclusion}`.
It is mainly useful in making requirements that constrain multiple time steps easier to read: for example, :scenic:`require always X implies Y` requires that at every time step when ``X`` holds, ``Y`` must also hold.

.. rubric:: References

.. [B10] Bauer et al., :title:`Comparing LTL Semantics for Runtime Verification`. Journal of Logic and Computation, 2010. `[Online] <https://doi.org/10.1093/logcom/exn075>`_


..  _functions:

****************************
Built-in Functions Reference
****************************

These functions are built into Scenic and may be used without needing to import any modules.

.. _gen_lifted_funcs:

Miscellaneous Python Functions
------------------------------

The following functions work in the same way as their Python counterparts except that they accept random values:

* :obj:`~math.sin`, :obj:`~math.cos`, :obj:`~math.hypot` (from the Python `math` module)
* `len`, `max`, `min`, `round`
* `float`, `int`, `str`

The other Python built-in functions (e.g. `enumerate`, `range`, `open`) are available but do not accept random arguments.

.. note::

	If in the definition of a scene you would like to pass random values into some other function from the Python standard library (or any other Python package), you will need to wrap the function with the `distributionFunction` decorator. This is not necessary when calling external functions inside requirements or dynamic behaviors.

.. _filter_func:

filter
------

The `filter` function works as in Python except it is now able to operate over random lists.
This feature can be used to work around Scenic's lack of support for randomized control flow in certain cases.
In particular, Scenic does not allow iterating over a random list, but it is still possible to select a random element satisfying a desired criterion using `filter`::

	mylist = Uniform([-1, 1, 2], [-3, 4])    # pick one of these lists 50/50
	filtered = filter(lambda e: e > 0, y)    # extract only the positive elements
	x = Uniform(*filtered)                   # pick one of them at random

In the last line, we use Python's `unpacking operator * <https://docs.python.org/3.6/reference/expressions.html#expression-lists>`_ to use the elements of the chosen list which pass the filter as arguments to :ref:`Uniform <Uniform({value}, {...})>`; thus ``x`` is sampled as a uniformly-random choice among such elements. [#f1]_

For an example of this idiom in a realistic scenario, see :file:`examples/driving/OAS_scenarios/oas_scenario_28.scenic`.

.. _resample_func:
.. _resample:

resample
--------
The `resample` function takes a distribution and samples a new value from it, conditioned on the values of its parameters, if any.
This is useful in cases where you have a complicated distribution that you want multiple samples from.

For example, in the program

.. code-block:: scenic

	x = Uniform(0, 5)
	y = Range(x, x+1)
	z = resample(y)

with probability 1/2 both ``y`` and ``z`` are independent uniform samples from the interval :math:`(0, 1)`, and with probability 1/2 they are independent uniform samples from :math:`(5, 6)`.
It is never the case that :math:`y \in (0, 1)` and :math:`z \in (5, 6)` or vice versa, which would require inconsistent assignments to ``x``.

.. note::

	This function can only be applied to the basic built-in distributions (see the :ref:`distributions`).
	Resampling a more complex expression like :scenic:`x + y` where ``x`` and ``y`` are distributions would be ambiguous (what if ``x`` and ``y`` are used elsewhere?) and so is not allowed.

.. _localPath_func:

localPath
---------
The `localPath` function takes a relative path with respect to the directory containing the ``.scenic`` file where it is used, and converts it to an absolute path. Note that the path is returned as a `pathlib.Path` object.

.. versionchanged:: 3.0

    This function now returns a `pathlib.Path` object instead of a string.

.. _verbosePrint_func:

verbosePrint
------------
The `verbosePrint` function operates like `print` except that it you can specify at what verbosity level (see :option:`--verbosity`) it should actually print.
If no level is specified, it prints at all levels except verbosity 0.

Scenic libraries intended for general use should use this function instead of `print` so that all non-error messages from Scenic can be silenced by setting verbosity 0.

.. _simulation_func:

simulation
----------
The `simulation` function, available for use in dynamic behaviors and scenarios, returns the currently-running `Simulation`.
This allows access to global information about the simulation, e.g. :scenic:`simulation().currentTime` to find the current time step; however, it is provided primarily so that scenarios written for a specific simulator may use simulator-specific functionality (by calling custom methods provided by that simulator's subclass of `Simulation`).

.. [#f1] If there are no such elements, i.e., the filtered list is empty, then Scenic will reject the scenario and try sampling again.



.. _visibility:

*****************
Visibility System
*****************

The Scenic visibility system is composed of two main parts: *visible regions* and *visibility checks*, which are described in detail below. An object is defined to be visible (modulo occlusion) if it lies within the horizontal and vertical :prop:`viewAngles` of the object and is within it's :prop:`visibleDistance`, i.e. if it lies in the *visible region* of the object. This is not how Scenic actually checks visibility though, instead relying on *visibility checks* which internally use ray tracing and can account for occlusion. 

===============
Visible Regions
===============

All Scenic objects define a *visible region*, a `Region` that is "visible" from a given `Object`. This region is defined by two groups of properties: spatial ones like :prop:`position` and :prop:`orientation`, and visibility specific ones:

 * :prop:`viewAngles` : The horizontal and vertical angles (in radians) of the object's field of view. The horizontal view angle must be between 0 and 2π and the vertical view angle must be between 0 and π.

 * :prop:`visibleDistance`: Distance used to determine the visible range of the object.

 * :prop:`cameraOffset`: Position of the camera relative to the object's :prop:`position`.

While visible regions do in fact define what an object can see, Scenic does not directly use them to determine if something is visible from an object: instead they serve an accessory role (e.g. making sampling more efficient). The visible region of a `Point` is a sphere, while that of an `OrientedPoint` or `Object` can be a variety of shapes (see `ViewRegion` for details). An object's visible region is used by various specifiers and operators, such as the :keyword:`visible {region}` operator, the :keyword:`visible <visible_spec>` specifier, etc. Note that an object's visible region is represented by a mesh and so is not exact, and that while Scenic takes occlusion by other objects into account when testing visibility, the visible region itself ignores occlusion. 


=================
Visibility Checks
=================

It is often useful to determine whether something is actually visible from another object, i.e. a visibility check. Scenic performs such checks using ray tracing, allowing it to account for other objects occluding visibility. Something is considered visible if any ray (within :prop:`viewAngles`) collides with it (within :prop:`visibleDistance`), without colliding with an occluding object first. Since Scenic sends a finite number of rays, it is possible for false negatives to occur, though this can be tuned using the properties below. Visibility checks are used by various specifiers and operators, such as the :keyword:`can see` operator, the :keyword:`visible <visible_spec>` specifier, etc.

Various object properties directly affect how Scenic performs visibility checks (including those listed above for visible regions):

 * :prop:`viewRayDensity`: By default determines the number of rays used during visibility checks. This value is the density of rays per
   degree of visible range in one dimension. The total number of rays sent will be this value squared per square degree of this object's
   view angles. This value determines the default value for :prop:`viewRayCount`, so if :prop:`viewRayCount` is overwritten this value is ignored.

 * :prop:`viewRayCount`: The total number of horizontal and vertical view angles to be sent, or None if this value should be computed
   automatically.

 * :prop:`viewRayDistanceScaling`: Whether or not the number of rays should scale with the distance to the object. Ignored if 
   :prop:`viewRayCount` is passed.

 * :prop:`occluding`: Whether or not this object occludes visibility.

Scenic uses several internal heuristics to speed up visibility checks, such as only sending rays where an object might actually be visible. Even with these heuristics, certain types of checks, such as those where an object is fully occluded but would otherwise be visible, can be very expensive. We recommend tuning :prop:`viewRayDensity` if runtimes are problematic, though note this may increase the risk of false negatives. Setting :prop:`viewRayDistanceScaling` to ``True`` can also help, especially in situations where objects can be very far away or very close, but one wishes to avoid setting :prop:`viewRayDensity` to a higher value. If one is seeking to emulate a specific camera resolution, one might instead wish to directly set :prop:`viewRayCount` (e.g. setting it to (1920, 1080) to emulate a full HD camera).



.. _scene generation:

****************
Scene Generation
****************

The "output" of a Scenic program has two parts: a *scene* describing a configuration of physical objects, and a *policy* defining how those objects behave over time.
The latter is relevant only for running dynamic simulations from a Scenic program, and is discussed in our page on `dynamic scenario semantics`.
In this page, we describe how scenes are generated from a Scenic program.

In Scenic, a scene consists of the following data:

	* a set of `objects <Object>` present in the scene (one of which *may* be designated the :scenic:`ego` object);
	* concrete values for all of the properties of these objects, such as :prop:`position`, :prop:`heading`, etc.;
	* concrete values for each :term:`global parameter`.

A Scenic program defines a probability distribution over such scenes in the usual way for imperative probabilistic programming languages with constraints (often called *observations*).
Running the program ignoring any :keyword:`require` statements and making random choices whenever a distribution is evaluated yields a distribution over possible executions of the program and therefore over generated scenes.
Then any executions which violate a :keyword:`require` condition are discarded, normalizing the probabilities of the remaining executions.

The Scenic tool samples from this distribution using rejection sampling: repeatedly sampling scenes until one is found which satisfies the requirements.
This approach has the advantage of allowing arbitrarily-complex requirements and sampling from the exact distribution we want.
However, if the requirements have a low probability of being satisfied, it may take many iterations to find a valid scene: in the worst case, if the requirements cannot be satisfied, rejection sampling will run forever (although the `Scenario.generate` function imposes a finite limit on the number of iterations by default).
To reduce the number of iterations required in some common cases, Scenic applies several "pruning" techniques to exclude parts of the scene space which violate the requirements ahead of time (this is done during compilation; see `our paper <publications>` for details).
The scene generation procedure then works as follows:

1. Decide which user-defined requirements will be enforced for this sample (`soft requirements <soft-requirements>` have only some probability of being required).
2. Invoke the external sampler to sample any :term:`external parameters`.
3. Sample values for all distributions defined in the scene (all expressions which have random values, represented internally as `Distribution` objects).
4. Check if the sampled values satisfy the built-in and user-defined requirements: if not, reject the sample and repeat from step (2).



.. _dynamic scenario semantics:

******************************
Execution of Dynamic Scenarios
******************************

As described in our tutorial on `dynamics`, Scenic scenarios can specify the behavior of agents over time, defining a *policy* which chooses :term:`actions` for each agent at each time step.
Having sampled an initial scene from a Scenic program (see `scene generation`), we can run a dynamic simulation by setting up the scene in a simulator and running the policy in parallel to control the agents.
The API for running dynamic simulations is described in `api` (mainly the `Simulator.simulate` method); this page details how Scenic executes such simulations.

The policy for each agent is given by its :term:`dynamic behavior`, which is a coroutine that usually executes like an ordinary function, but is suspended when it takes an action (using :keyword:`take` or :keyword:`wait`) and resumed after the simulation has advanced by one time step.
As a result, behaviors effectively run in parallel with the simulation.
Behaviors are also suspended when they invoke a sub-behavior using :keyword:`do`, and are not resumed until the sub-behavior terminates.

When a behavior is first invoked, its preconditions are checked, and if any are not satisfied, the simulation is rejected, requiring a new simulation to be sampled. [#f1]_
The behavior's invariants are handled similarly, except that they are also checked whenever the behavior is resumed (i.e. after taking an action and after a sub-behavior terminates).

:term:`Monitors` and :keyword:`compose` blocks of :term:`modular scenarios` execute in the same way as behaviors, with :keyword:`compose` blocks also including additional checks to see if any of their :keyword:`terminate when` conditions have been met or their :term:`temporal requirements` violated.

In detail, a single time step of a dynamic simulation is executed according to the following procedure:

1. Execute all currently-running :term:`modular scenarios` for one time step.
   Specifically, for each such scenario:

	a. Check if any of its :term:`temporal requirements` have already been violated [#f2]_; if so, reject the simulation.

	b. Check if the scenario's time limit (if :keyword:`terminate after` has been used) has been reached; if so, go to step (e) below to stop the scenario.

	c. If the scenario is not currently running a sub-scenario (with :keyword:`do`), check its invariants; if any are violated, reject the simulation. [#f1]_

	d. If the scenario has a :keyword:`compose` block, run it for one time step (i.e. resume it until it or a subscenario it is currently running using :keyword:`do` executes :keyword:`wait`).
	   If the block executes a :keyword:`require` statement with a false condition, reject the simulation.
	   If it executes :keyword:`terminate` or :keyword:`terminate simulation`, or finishes executing, go to step (e) below to stop the scenario.

	e. If the scenario is stopping for one of the reasons above, first recursively stop any sub-scenarios it is running, then revert the effects of any :keyword:`override` statements it executed.
	   Next, check if any of its :term:`temporal requirements` were not satisfied: if so, reject the simulation.
	   Otherwise, the scenario returns to its parent scenario if it was invoked using :keyword:`do`; if it was the top-level scenario, or if it executed :keyword:`terminate simulation`, we set a flag indicating the top-level scenario has terminated.
	   (We do not terminate immediately since we still need to check monitors in the next step.)

2. Save the values of all :keyword:`record` statements, as well as :keyword:`record initial` statements if it is time step 0.

3. Run each :term:`monitor` instantiated in the currently-running scenarios for one time step (i.e. resume it until it executes :keyword:`wait`).
   If it executes a :keyword:`require` statement with a false condition, reject the simulation.
   If it executes :keyword:`terminate`, stop the scenario which instantiated it as in step (1e) above.
   If it executes :keyword:`terminate simulation`, set the termination flag (and continue running any other monitors).

4. If the termination flag is set, any of the :keyword:`terminate simulation when` conditions are satisfied, or a time limit passed to `Simulator.simulate` has been reached, go to step (10) to terminate the simulation.

5. Execute the :term:`dynamic behavior` of each agent to select its action(s) for the time step.
   Specifically, for each agent's behavior:

	a. If the behavior is not currently running a sub-behavior (with :keyword:`do`), check its invariants; if any are violated, reject the simulation. [#f1]_

	b. Resume the behavior until it (or a subbehavior it is currently running using :keyword:`do`) executes :keyword:`take` or :keyword:`wait`.
	   If the behavior executes a :keyword:`require` statement with a false condition, reject the simulation.
	   If it executes :keyword:`terminate`, stop the scenario which defined the agent as in step (1e) above.
	   If it executes :keyword:`terminate simulation`, go to step (10) to terminate the simulation.
	   Otherwise, save the (possibly empty) set of actions specified for the agent to take.

6. For each agent, execute the :term:`actions` (if any) its behavior chose in the previous step.

7. Run the simulator for one time step.

8. Increment the simulation clock (the ``currentTime`` attribute of `Simulation`).

9. Update every :term:`dynamic property` of every object to its current value in the simulator.

10. If the simulation is stopping for one of the reasons above, first check if any of the :term:`temporal requirements` of any remaining scenarios were not satisfied: if so, reject the simulation.
    Otherwise, save the values of any :keyword:`record final` statements.


.. rubric:: Footnotes

.. [#f1] By default, violations of preconditions and invariants cause the simulation to be rejected; however, `Simulator.simulate` has an option to treat them as fatal errors instead.

.. [#f2] More precisely, whether it is impossible for the requirement to be satisfied no matter how the simulation continues.
   For example, given the requirement :scenic:`require always X`, if ``X`` is false in the current time step then the whole simulation will certainly violate the requirement and we can reject.
   On the other hand, given the requirement :scenic:`require eventually X`, the fact that ``X`` is currently false does not mean the requirement will necessarily be violated, since ``X`` could become true later.
   For such requirements Scenic will not reject until the simulation has completed, at which point we can tell with certainty whether or not the requirement was satisfied.